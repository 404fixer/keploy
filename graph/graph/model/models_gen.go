// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type BodyResult struct {
	Type     *string `json:"type,omitempty"`
	Normal   *bool   `json:"normal,omitempty"`
	Expected *string `json:"expected,omitempty"`
	Actual   *string `json:"actual,omitempty"`
}

type FormData struct {
	Key    *string   `json:"key,omitempty"`
	Values []*string `json:"values,omitempty"`
	Paths  []*string `json:"paths,omitempty"`
}

type Header struct {
	Key   *string   `json:"key,omitempty"`
	Value []*string `json:"value,omitempty"`
}

type HeaderResult struct {
	Normal   *bool   `json:"normal,omitempty"`
	Expected *Header `json:"expected,omitempty"`
	Actual   *Header `json:"actual,omitempty"`
}

type HTTPReq struct {
	Method     *Method     `json:"method,omitempty"`
	ProtoMajor *int        `json:"protoMajor,omitempty"`
	ProtoMinor *int        `json:"protoMinor,omitempty"`
	URL        *string     `json:"url,omitempty"`
	URLParams  []*Kv       `json:"urlParams,omitempty"`
	Header     []*Kv       `json:"header,omitempty"`
	Body       *string     `json:"body,omitempty"`
	BodyType   *string     `json:"bodyType,omitempty"`
	Binary     *string     `json:"binary,omitempty"`
	Form       []*FormData `json:"form,omitempty"`
}

type HTTPResp struct {
	StatusCode    *int    `json:"statusCode,omitempty"`
	Header        []*Kv   `json:"header,omitempty"`
	Body          *string `json:"body,omitempty"`
	BodyType      *string `json:"bodyType,omitempty"`
	StatusMessage *string `json:"statusMessage,omitempty"`
	ProtoMajor    *int    `json:"protoMajor,omitempty"`
	ProtoMinor    *int    `json:"protoMinor,omitempty"`
	Binary        *string `json:"binary,omitempty"`
}

type IntResult struct {
	Normal   *bool `json:"normal,omitempty"`
	Expected *int  `json:"expected,omitempty"`
	Actual   *int  `json:"actual,omitempty"`
}

type Kv struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

type MetaKeyValue struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

type Mock struct {
	Version  *Version `json:"version,omitempty"`
	Kind     *Kind    `json:"kind,omitempty"`
	MockName *string  `json:"mockName,omitempty"`
	Spec     *string  `json:"spec,omitempty"`
}

type Result struct {
	StatusCode    *IntResult      `json:"statusCode,omitempty"`
	HeadersResult []*HeaderResult `json:"headersResult,omitempty"`
	BodyResult    []*BodyResult   `json:"bodyResult,omitempty"`
	MockResult    []*MockResult   `json:"mockResult,omitempty"`
}

type Test struct {
	Status     *TestStatus `json:"status,omitempty"`
	Started    *string     `json:"started,omitempty"`
	Completed  *string     `json:"completed,omitempty"`
	TestCaseID *string     `json:"testCaseId,omitempty"`
	URI        *string     `json:"uri,omitempty"`
	Req        *HTTPReq    `json:"req,omitempty"`
	HTTPResp   *HTTPResp   `json:"http_resp,omitempty"`
	Noise      []*string   `json:"noise,omitempty"`
	Result     *Result     `json:"result,omitempty"`
}

type TestCase struct {
	TestCaseName *string   `json:"testCaseName,omitempty"`
	Created      *string   `json:"created,omitempty"`
	Cid          *string   `json:"cid,omitempty"`
	HTTPReq      *HTTPReq  `json:"httpReq,omitempty"`
	HTTPResp     *HTTPResp `json:"httpResp,omitempty"`
	Noise        []string  `json:"noise,omitempty"`
	Mocks        []*Mock   `json:"mocks,omitempty"`
	Type         *string   `json:"type,omitempty"`
}

type TestReport struct {
	ID      *string  `json:"id,omitempty"`
	Version *Version `json:"version,omitempty"`
	Name    *string  `json:"name,omitempty"`
	Status  *string  `json:"status,omitempty"`
	Success *int     `json:"success,omitempty"`
	Failure *int     `json:"failure,omitempty"`
	Total   *int     `json:"total,omitempty"`
	Tests   []*Test  `json:"tests,omitempty"`
}

type TestSuite struct {
	TestSuiteName *string `json:"testSuiteName,omitempty"`
	TestSuitePath *string `json:"testSuitePath,omitempty"`
}

type MockMetaResult struct {
	Normal   *bool   `json:"normal,omitempty"`
	Key      *string `json:"key,omitempty"`
	Expected *string `json:"expected,omitempty"`
	Actual   *string `json:"actual,omitempty"`
}

type MockResult struct {
	Name *string           `json:"name,omitempty"`
	Type *MockType         `json:"type,omitempty"`
	Meta []*MockMetaResult `json:"meta,omitempty"`
}

type Kind string

const (
	KindHTTP       Kind = "HTTP"
	KindGeneric    Kind = "GENERIC"
	KindSQL        Kind = "SQL"
	KindGrpcExport Kind = "GRPC_EXPORT"
)

var AllKind = []Kind{
	KindHTTP,
	KindGeneric,
	KindSQL,
	KindGrpcExport,
}

func (e Kind) IsValid() bool {
	switch e {
	case KindHTTP, KindGeneric, KindSQL, KindGrpcExport:
		return true
	}
	return false
}

func (e Kind) String() string {
	return string(e)
}

func (e *Kind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Kind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Kind", str)
	}
	return nil
}

func (e Kind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Method string

const (
	MethodGet     Method = "GET"
	MethodPut     Method = "PUT"
	MethodHead    Method = "HEAD"
	MethodPost    Method = "POST"
	MethodPatch   Method = "PATCH"
	MethodDelete  Method = "DELETE"
	MethodOptions Method = "OPTIONS"
	MethodTrace   Method = "TRACE"
)

var AllMethod = []Method{
	MethodGet,
	MethodPut,
	MethodHead,
	MethodPost,
	MethodPatch,
	MethodDelete,
	MethodOptions,
	MethodTrace,
}

func (e Method) IsValid() bool {
	switch e {
	case MethodGet, MethodPut, MethodHead, MethodPost, MethodPatch, MethodDelete, MethodOptions, MethodTrace:
		return true
	}
	return false
}

func (e Method) String() string {
	return string(e)
}

func (e *Method) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Method(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Method", str)
	}
	return nil
}

func (e Method) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TestStatus string

const (
	TestStatusPending TestStatus = "Pending"
	TestStatusRunning TestStatus = "Running"
	TestStatusFailed  TestStatus = "Failed"
	TestStatusPassed  TestStatus = "Passed"
)

var AllTestStatus = []TestStatus{
	TestStatusPending,
	TestStatusRunning,
	TestStatusFailed,
	TestStatusPassed,
}

func (e TestStatus) IsValid() bool {
	switch e {
	case TestStatusPending, TestStatusRunning, TestStatusFailed, TestStatusPassed:
		return true
	}
	return false
}

func (e TestStatus) String() string {
	return string(e)
}

func (e *TestStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TestStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TestStatus", str)
	}
	return nil
}

func (e TestStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Version string

const (
	VersionV1Beta1 Version = "V1Beta1"
	VersionV1Beta2 Version = "V1Beta2"
)

var AllVersion = []Version{
	VersionV1Beta1,
	VersionV1Beta2,
}

func (e Version) IsValid() bool {
	switch e {
	case VersionV1Beta1, VersionV1Beta2:
		return true
	}
	return false
}

func (e Version) String() string {
	return string(e)
}

func (e *Version) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Version(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Version", str)
	}
	return nil
}

func (e Version) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MockType string

const (
	MockTypeNoSQLDb    MockType = "NoSqlDB"
	MockTypeSQLDb      MockType = "SqlDB"
	MockTypeGrpc       MockType = "GRPC"
	MockTypeHTTPClient MockType = "HttpClient"
)

var AllMockType = []MockType{
	MockTypeNoSQLDb,
	MockTypeSQLDb,
	MockTypeGrpc,
	MockTypeHTTPClient,
}

func (e MockType) IsValid() bool {
	switch e {
	case MockTypeNoSQLDb, MockTypeSQLDb, MockTypeGrpc, MockTypeHTTPClient:
		return true
	}
	return false
}

func (e MockType) String() string {
	return string(e)
}

func (e *MockType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MockType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid mockType", str)
	}
	return nil
}

func (e MockType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
